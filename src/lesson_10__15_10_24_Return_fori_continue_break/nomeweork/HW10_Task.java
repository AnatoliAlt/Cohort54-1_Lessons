package lesson_10__15_10_24_Return_fori_continue_break.nomeweork;
/*
Task 1
Написать метод со следующим функционалом:
На вход метод принимает массив целых чисел и число - длину нового массива. Метод должен
создать и распечатать массив заданной в параметрах длинны. В начало массива должны быть скопированы
элементы из входящего массива:
{0, 1, 2, 3, 4, 5, 6} -> copyOfArray(array, 3) -> вывод на печать {0, 1, 2}
Copy
{0, 1, 2} -> copyOfArray(array, 5) -> вывод на печать {0, 1, 2, 0, 0}
Copy
Arrays.copyOf() использовать нельзя. Суть задачи - написать собственную реализацию этого метода

Task 2
Написать метод, принимающий на вход массив строк. Метод должен вернуть массив, состоящий из самой
короткой и самой длинной строки изначального массива.

Task 3
Написать метод, принимающий на вход массив целых чисел. Метод должен вернуть массив, состоящий только из простых
чисел, присутствующих в изначальном массиве
вход -> {0, 13, -25, 11, 31, 55, 98, 11, 5} -> выход {13, 11, 31, 11, 5}


Task 4* со звездочкой (Опционально)
Дано: Два отсортированных массива целых чисел. Вам нужно найти элемент, который будет находиться на k-й
позиции в объединенном отсортированном массиве.
Массив 1 - {100, 112, 256, 349, 770}
Массив 2 - {72, 86, 113, 119, 265, 445, 892}
k = 7
Copy
Вывод : 256
Можно такой вывод:
72, 86, 100, 112, 113, 119, 256
Искомое число: 256
Copy
Объединенный отсортированный массив был бы такой (выводить, формировать его не обязательно) -

[72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892]
Copy
7-й элемент (по счету) этого массива хранит значение 256.
 */

public class HW10_Task {
}
